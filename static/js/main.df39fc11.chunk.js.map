{"version":3,"sources":["GameCell.js","Timer.js","App.js","serviceWorker.js","index.js"],"names":["privateConstantMap","GameCell","props","state","clicked","flag","handleCellClicked","bind","handleRightClick","target","this","row","column","clickedCell","mine","count","console","log","setState","e","preventDefault","rightClickedCell","flagClass","mineClass","countClass","toString","id","className","onClick","onContextMenu","Component","Timer","initialState","elapsedTime","initTime","start","Date","now","timer","setInterval","totalSeconds","sec","Math","floor","displaySec","min","App","nRows","nCols","nMines","Gameboard","nmarked","nuncovered","exploded","arr","array2d","uncover","nrows","ncols","val","res","col","max","ceil","random","r","c","dr","dc","validCoord","allowed","abs","push","length","i","j","rndInt","mines","s","gameboardArr","map","slice","join","sprinkleMines","uncoveredUpdated","ff","lost","alert","window","location","reload","totalHiddenSquares","a","done","item","key","subitem","mark","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.df39fc11.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\nimport './App.css';\r\nimport Gameboard from './App.js';\r\n\r\n\r\ntype Props = {\r\n  row: number,\r\n  column: number,\r\n  state: String,\r\n  mine: Boolean,\r\n  count: number,\r\n  clickedCell: Function,\r\n  rightClickedCell: Function\r\n};\r\n\r\ntype State = {\r\n  clicked: Boolean,\r\n  flag: Boolean\r\n}\r\n// private constants\r\nconst privateConstantMap = {\r\n  STATE_HIDDEN: \"hidden\",\r\n  STATE_SHOWN: \"shown\",\r\n  STATE_MARKED: \"marked\"\r\n};\r\n\r\nclass GameCell extends Component<Props, State> {\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { clicked: false, flag: false };\r\n    this.handleCellClicked = this.handleCellClicked.bind(this);\r\n    this.handleRightClick = this.handleRightClick.bind(this);\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  handleCellClicked({ target }: SyntheticMouseEvent<>) {\r\n    let {row, column, state, mine, count, clickedCell} = this.props;\r\n    let {clicked, flag} = this.state;\r\n    console.log(\"I was clicked in r,c:\" + row + \",\" + column);\r\n    //If there is no flag on this cell, set clicked to true\r\n    if(!flag) {\r\n      //clicked = true;\r\n      this.setState({clicked: true});\r\n    }\r\n    \r\n    if(typeof state !== 'undefined') {\r\n      if(state !== privateConstantMap.STATE_HIDDEN) {\r\n        console.log(\"This cell is already shown, set as clicked\");\r\n        clicked = true;\r\n        this.setState({clicked: true});\r\n        //return;\r\n      }\r\n    }\r\n    \r\n    //If it hasn't been clicked before, call uncover method from Gameboard\r\n    console.log(\"clicked state is: \" + this.state.clicked + \" clicked var is: \" + clicked);\r\n    if(!clicked) {\r\n      clickedCell(row, column);\r\n    }\r\n\r\n  }\r\n\r\n  handleRightClick(e: SyntheticMouseEvent<>) {\r\n    e.preventDefault();\r\n    let {row, column, rightClickedCell, state} = this.props;\r\n    let {clicked, flag} = this.state;\r\n    if(!clicked) {\r\n      if(state !== privateConstantMap.STATE_SHOWN) {\r\n        if(flag) {\r\n          this.setState({flag: false});\r\n        } else {\r\n          this.setState({flag: true});\r\n        }\r\n        rightClickedCell(row, column);\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    let {row, column, state, mine, count, clickedCell, rightClickedCell} = this.props;\r\n    let {flag} = this.state;\r\n    const flagClass = (flag && state === privateConstantMap.STATE_HIDDEN) ? 'marked' : ''\r\n    const mineClass =  mine ? 'mine' : ''\r\n    const countClass = count.toString();\r\n    //const stateClass = (state=== 'hidden') ? ''\r\n    return(\r\n      <td id={`${row}_${column}`}\r\n        className={`${mineClass} ${flagClass} ${state} _${countClass}`}\r\n        onClick={this.handleCellClicked.bind(this)}\r\n        onContextMenu={this.handleRightClick.bind(this)}\r\n        >\r\n          {(state === privateConstantMap.STATE_SHOWN) ? count : ''}\r\n      </td>\r\n    );\r\n  }\r\n\r\n\r\n} export default GameCell;\r\n","import React, {Component} from 'react';\r\n\r\nclass Timer extends Component<State> {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = this.initialState = {\r\n            elapsedTime: 0,\r\n            initTime: 0\r\n        };\r\n        this.start = this.start.bind(this);\r\n    }\r\n\r\n    /**\r\n     *  This method gets called when the start button gets clicked and begins\r\n     *  the timer. \r\n     */\r\n    start() {\r\n        this.setState(state => {\r\n            const initTime = Date.now() - this.state.elapsedTime;\r\n            this.timer = setInterval(() =>  {\r\n                this.setState({elapsedTime: Date.now() - initTime});\r\n            });\r\n       });\r\n    }\r\n\r\n    render() {\r\n        const totalSeconds = this.state.elapsedTime;\r\n        const sec = Math.floor(totalSeconds / 1000).toString();\r\n        const displaySec = Math.floor(sec % 60).toString();\r\n        const min = Math.floor(totalSeconds /60000).toString();\r\n    \r\n        return( \r\n        <div id=\"timer-wrapper\">\r\n            <p>{min}m:{displaySec}s</p>\r\n            <button id=\"timer-start-button\" className=\"timer-button\" onClick={this.start}> Start</button>\r\n        </div>\r\n        );\r\n\r\n    }\r\n} export default Timer;","import React, {Component} from 'react';\r\nimport './App.css';\r\nimport GameCell from './GameCell';\r\nimport Timer from './Timer'\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <h1>Minesweeper</h1>\r\n        <Timer/>       \r\n        <Gameboard nRows=\"10\" nCols=\"10\" nMines=\"8\"></Gameboard>\r\n        <p>Remaining mines: 8</p>\r\n      </header>\r\n    </div>\r\n  );\r\n} export default App;\r\n\r\n\r\n// private constants\r\nconst privateConstantMap = {\r\n  STATE_HIDDEN: \"hidden\",\r\n  STATE_SHOWN: \"shown\",\r\n  STATE_MARKED: \"marked\"\r\n};\r\n\r\ntype Props = {};\r\ntype State = {\r\n  nCols: number,\r\n  nRows: number,\r\n  nMines: number,\r\n  nmarked: number,\r\n  nuncovered: number,\r\n  exploded: Boolean,\r\n  arr: Array<Array<>>\r\n};\r\n/**\r\n * Gameboard is the grid composed of a 2D array that represents\r\n * the minesweeper UI\r\n */\r\nexport class Gameboard extends Component<State, Props> {\r\n  \r\n  constructor(props) {\r\n    super(props);\r\n    let nCols = 10;\r\n    let nRows = 10;\r\n    let nMines = 8;\r\n    let nmarked = 0;\r\n    let nuncovered = 0;\r\n    let exploded = false;\r\n\r\n    this.state = {\r\n      nCols,\r\n      nRows,\r\n      nMines,\r\n      nmarked,\r\n      nuncovered,\r\n      exploded,\r\n      arr: this.array2d(nRows, nCols,\r\n        () => ({mine: false, state: privateConstantMap.STATE_HIDDEN, count: 0}))\r\n    };\r\n    //this.ff = this.ff.bind(this);\r\n    this.uncover = this.uncover.bind(this);\r\n  }\r\n\r\n  /**\r\n   * 2D array representing the gameboard\r\n   * @param {*} nrows \r\n   * @param {*} ncols \r\n   * @param {*} val \r\n   */\r\n  array2d( nrows, ncols, val) {\r\n    const res = [];\r\n    for( let row = 0 ; row < nrows ; row ++) {\r\n      res[row] = [];\r\n      for( let col = 0 ; col < ncols ; col ++)\r\n        res[row][col] = val(row,col);\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  // returns random integer in range [min, max]\r\n  rndInt(min, max) {\r\n    [min,max] = [Math.ceil(min), Math.floor(max)]\r\n    return min + Math.floor(Math.random() * (max - min + 1));\r\n  }\r\n\r\n  validCoord(row, col) {\r\n    return row >= 0 && row < this.state.nRows && col >= 0 && col < this.state.nCols;\r\n  }\r\n\r\n  count(row,col) {\r\n    const c = (r,c) =>\r\n          (this.validCoord(r,c) && this.state.arr[r][c].mine ? 1 : 0);\r\n    let res = 0;\r\n    for( let dr = -1 ; dr <= 1 ; dr ++ )\r\n      for( let dc = -1 ; dc <= 1 ; dc ++ )\r\n        res += c(row+dr,col+dc);\r\n    return res;\r\n  }\r\n\r\n  sprinkleMines(row, col) {\r\n    // prepare a list of allowed coordinates for mine placement\r\n    let allowed = [];\r\n    for(let r = 0 ; r < this.state.nRows ; r ++ ) {\r\n      for( let c = 0 ; c < this.state.nCols ; c ++ ) {\r\n        if(Math.abs(row-r) > 2 || Math.abs(col-c) > 2)\r\n          allowed.push([r,c]);\r\n      }\r\n    }\r\n   \r\n    this.state.nMines = Math.min(this.state.nMines, allowed.length);\r\n    for( let i = 0 ; i < this.state.nMines ; i ++ ) {\r\n      let j = this.rndInt(i, allowed.length-1);\r\n      [allowed[i], allowed[j]] = [allowed[j], allowed[i]];\r\n      let [r,c] = allowed[i];\r\n      this.state.arr[r][c].mine = true;\r\n      console.log(\"mine here: \" + \" r,c:\" + r + \",\" + c + \" \" + this.state.arr[r][c].mine);\r\n    }\r\n    // erase any marks (in case user placed them) and update counts\r\n    for(let r = 0 ; r < this.state.nRows ; r ++ ) {\r\n      for( let c = 0 ; c < this.state.nCols ; c ++ ) {\r\n        if(this.state.arr[r][c].state == privateConstantMap.STATE_MARKED) {\r\n          this.state.arr[r][c].state = privateConstantMap.STATE_HIDDEN; \r\n        }\r\n        this.state.arr[r][c].count = this.count(r,c);\r\n      }\r\n    }\r\n    let mines = []; let counts = [];\r\n    for(let row = 0 ; row < this.state.nRows ; row ++ ) {\r\n      let s = \"\";\r\n      for( let col = 0 ; col < this.state.nCols ; col ++ ) {\r\n        s += this.state.arr[row][col].mine ? \"B\" : \".\";\r\n      }\r\n      s += \"  |  \";\r\n      for( let col = 0 ; col < this.state.nCols ; col ++ ) {\r\n        s += this.state.arr[row][col].count.toString();\r\n      }\r\n      mines[row] = s;\r\n    }\r\n    let gameboardArr = this.state.arr.map(function(arr) {\r\n      return arr.slice();\r\n    });\r\n    this.setState({arr: gameboardArr});\r\n\r\n    console.log(\"Mines and counts after sprinkling:\");\r\n    console.log(mines.join(\"\\n\"), \"\\n\");\r\n  }\r\n\r\n  // uncovers a cell at a given coordinate\r\n  // this is the 'left-click' functionality\r\n  uncover(row, col) {\r\n    console.log(\"uncover\", row, col);\r\n    // if coordinates invalid, refuse this request\r\n    if( ! this.validCoord(row,col)) {\r\n      console.log(\"Requested coordinates (\" + row + \", \"+ col + \") were invalid.\");\r\n      return false; \r\n    }\r\n    let nuncovered = this.state.nuncovered;\r\n    console.log(\"beginning uncover method with nuncovered: \" + this.state.nuncovered\r\n    + \" with var: \" + nuncovered);\r\n\r\n    // if this is the very first move, populate the mines, but make\r\n    // sure the current cell does not get a mine\r\n    if( this.state.nuncovered === 0) {\r\n      console.log(\"populating with mines at: \" + row + \", \" + col);\r\n      this.sprinkleMines(row, col);\r\n    }\r\n    // if cell is not hidden, ignore this move\r\n    //this.state.arr[row][col].state !== privateConstantMap.STATE_HIDDEN //prev if statement\r\n    if( typeof this.state.arr[row][col].state !== 'undefined') {\r\n      console.log(\"state of this cell is not undefined, it's: \" + this.state.arr[row][col].state);\r\n      if(this.state.arr[row][col].state !== privateConstantMap.STATE_HIDDEN) {\r\n        return false; //STATE_HIDDEN\r\n      }\r\n    }\r\n    let gameboardArr = this.state.arr.map(function(arr) {\r\n      return arr.slice();\r\n    });\r\n\r\n    let uncoveredUpdated = this.state.nuncovered;\r\n    //floodfill all 0-count cells\r\n    const ff = (r, c, gameboardArr, uncoveredUpdated) => {\r\n      if(!this.validCoord(r,c)) {\r\n        return;\r\n      }\r\n      \r\n      if(typeof gameboardArr[r][c].state !== 'undefined'){ \r\n        if(gameboardArr[r][c].state !== privateConstantMap.STATE_HIDDEN) {\r\n          return; \r\n        }\r\n      }\r\n      gameboardArr[r][c].state = privateConstantMap.STATE_SHOWN;\r\n      uncoveredUpdated++;\r\n      //console.log(\"uncoveredupdated: \" + uncoveredUpdated);\r\n      this.state.nuncovered = uncoveredUpdated;\r\n      this.setState({nuncovered: uncoveredUpdated}, () => {\r\n       console.log(\"updated nuncovered state in ff: \" + this.state.nuncovered);\r\n      });\r\n      \r\n      if(gameboardArr[r][c].count !== 0) {\r\n        return;\r\n      }\r\n      ff(r-1,c-1, gameboardArr, uncoveredUpdated);ff(r-1,c, gameboardArr, uncoveredUpdated);ff(r-1,c+1, gameboardArr, uncoveredUpdated);\r\n      ff(r  ,c-1, gameboardArr, uncoveredUpdated);         ;ff(r  ,c+1, gameboardArr, uncoveredUpdated);\r\n      ff(r+1,c-1, gameboardArr, uncoveredUpdated);ff(r+1,c, gameboardArr, uncoveredUpdated);ff(r+1,c+1, gameboardArr, uncoveredUpdated);\r\n    };\r\n    ff(row,col, gameboardArr, uncoveredUpdated);\r\n    // for(let i = 0; i < gameboardArr.length; i++) {\r\n    //   for(let j = 0; j < gameboardArr.length; j++){\r\n    //     console.log(\"row: \" + i + \" col: \" + j + \" state: \" + gameboardArr[i][j].state + \" count: \" + gameboardArr[i][j].count + \" mine: \" + gameboardArr[i][j].mine);\r\n    //   }\r\n    // }\r\n    this.setState({arr: gameboardArr}, () => {\r\n      // for(let i = 0; i < this.state.arr.length; i++) {\r\n      //   for(let j = 0; j < this.state.arr.length; j++){\r\n      //     console.log(\"ARR row: \" + i + \" col: \" + j + \" state: \" + this.state.arr[i][j].state + \" count: \" + this.state.arr[i][j].count + \" mine: \" + this.state.arr[i][j].mine);\r\n      //   }\r\n      // }\r\n    });\r\n    \r\n    this.setState({nuncovered: this.state.nuncovered}, () => {\r\n      console.log(\"updated nuncovered state AFTER ff: \" + this.state.nuncovered);\r\n    });   \r\n    // have we hit a mine?\r\n    let lost = false;\r\n    if(this.state.arr[row][col].mine) {\r\n      console.log(\"Mine at \" + row + \", \" + col + \" was hit\");\r\n      this.state.exploded = true;\r\n      lost = true;\r\n      alert(\"You lost\");\r\n      window.location.reload(true);\r\n    }\r\n    if(!lost) {\r\n      let totalHiddenSquares = 0;\r\n      for(let i = 0; i < this.state.arr.length; i++) {\r\n        for(let j = 0; j < this.state.arr.length; j++) {\r\n          if(this.state.arr[i][j].state === privateConstantMap.STATE_HIDDEN) {\r\n            totalHiddenSquares++;\r\n            //console.log(\"Hidden Squares remaining: \" + totalHiddenSquares);\r\n          }\r\n        }\r\n      }\r\n      if(totalHiddenSquares === this.state.nMines) {\r\n        alert(\"You win!\");\r\n        window.location.reload(true);\r\n      }\r\n    }\r\n    \r\n   // this.getStatus();\r\n    console.log(\"nuncovered state value: \" + this.state.nuncovered + \" , uncoveredUpdated temp var: \" + uncoveredUpdated);\r\n    return true;\r\n  }\r\n\r\n  // puts a flag on a cell\r\n  // this is the 'right-click' or 'long-tap' functionality\r\n  mark(row, col) {\r\n    console.log(\"mark\", row, col);\r\n    // if coordinates invalid, refuse this request\r\n    if( ! this.validCoord(row,col)){\r\n      return false;\r\n    }\r\n    // if cell already uncovered, refuse this\r\n    console.log(\"marking previous state=\", this.state.arr[row][col].state);\r\n    if( this.state.arr[row][col].state === privateConstantMap.STATE_SHOWN) return false; //STATE_SHOWN\r\n    // accept the move and flip the marked status\r\n    this.nmarked += this.state.arr[row][col].state == privateConstantMap.STATE_MARKED ? -1 : 1;\r\n    this.state.arr[row][col].state = this.state.arr[row][col].state == privateConstantMap.STATE_MARKED ? \r\n    privateConstantMap.STATE_HIDDEN : privateConstantMap.STATE_MARKED; //STATE_HIDDEN:STATE_MARKED\r\n    return true;\r\n  }\r\n\r\n\r\n  // returns array of strings representing the rendering of the board\r\n  //      \"H\" = hidden cell - no bomb\r\n  //      \"F\" = hidden cell with a mark / flag\r\n  //      \"M\" = uncovered mine (game should be over now)\r\n  // '0'..'9' = number of mines in adjacent cells\r\n  getRendering() {\r\n    const res = [];\r\n    for( let row = 0 ; row < this.state.nRows ; row ++) {\r\n      let s = \"\";\r\n      for( let col = 0 ; col < this.state.nCols ; col ++ ) {\r\n        let a = this.state.arr[row][col];\r\n        if( this.exploded && a.mine) s += \"M\";\r\n        else if( a.state === privateConstantMap.STATE_HIDDEN) s += \"H\"; //statehidden\r\n        else if( a.state === privateConstantMap.STATE_MARKED) s += \"F\"; //state marked\r\n        else if( a.mine) s += \"M\";\r\n        else s += a.count.toString();\r\n      }\r\n      res[row] = s;\r\n    }\r\n    return res;\r\n  }\r\n\r\n  getStatus() {\r\n    let done = this.state.exploded ||\r\n        this.state.nuncovered === this.state.nRows * this.state.nCols - this.state.nMines;\r\n    if(done) {\r\n      alert(\"You win!\");\r\n    }\r\n    return {\r\n      done: done,\r\n      exploded: this.state.exploded,\r\n      nRows: this.state.nRows,\r\n      nCols: this.state.nCols,\r\n      nmarked: this.state.nmarked,\r\n      nuncovered: this.state.nuncovered,\r\n      nMines: this.state.nMines\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div id=\"gameboard-container\">\r\n        <table id=\"gameboard-table\">\r\n          <tbody>\r\n            {this.state.arr.map((item, row) => {\r\n              return(\r\n                <tr key={row}>\r\n                  {item.map((subitem, col) => {\r\n                    return (\r\n                      <GameCell \r\n                        key={col}\r\n                        row={row}\r\n                        column={col}\r\n                        state={subitem.state}\r\n                        mine={subitem.mine}\r\n                        count={subitem.count}\r\n                        clickedCell={this.uncover.bind(this)}\r\n                        rightClickedCell={this.mark.bind(this)}\r\n                      >\r\n                      </GameCell>\r\n                    );\r\n                  }\r\n                  )}\r\n                </tr>\r\n              );\r\n            })}\r\n          </tbody>  \r\n        </table>   \r\n      </div>\r\n    );\r\n  }\r\n};\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}